Metadata-Version: 2.4
Name: systemd_monitor
Version: 0.1.0.post41+gcade8a2d3
Summary: A Python package for monitoring systemd services via D-Bus
Author-email: Your Name <your.email@example.com>
License-Expression: MIT
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: System Administrators
Classifier: Operating System :: POSIX :: Linux
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Topic :: System :: Monitoring
Classifier: Topic :: System :: Systems Administration
Requires-Python: >=3.7
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: jeepney>=0.8.0
Provides-Extra: metrics
Requires-Dist: prometheus-client>=0.14.0; extra == "metrics"
Provides-Extra: dev
Requires-Dist: pytest>=6.0; extra == "dev"
Requires-Dist: pytest-cov>=2.0; extra == "dev"
Requires-Dist: pytest-mock>=3.6.0; extra == "dev"
Requires-Dist: black>=21.0; extra == "dev"
Requires-Dist: flake8>=3.8; extra == "dev"
Requires-Dist: mypy>=0.800; extra == "dev"
Requires-Dist: pre-commit>=2.0; extra == "dev"
Dynamic: license-file

# Systemd Monitor

`systemd_monitor.py` is a Python script designed to monitor the state of specified systemd services on a Linux system. It uses an **event-driven architecture** with D-Bus `PropertiesChanged` callbacks for real-time notification of service state changes. All monitored events are logged to a file with persistent counters tracking service starts, stops, and crashes across script runs.

## Features

*   **Event-Driven Architecture**: Uses D-Bus `PropertiesChanged` callbacks for immediate, efficient state change notifications
*   **Persistent State Tracking**: Counts of starts, stops, and crashes are persisted to JSON and survive script restarts
*   **Real-Time Logging**: Logs all service state changes with timestamps to rotating log files
*   **Prometheus Metrics**: Built-in metrics exporter for monitoring with Prometheus/Grafana
*   **Pure Python Implementation**: 100% pure Python using Jeepney - no C compiler required!
*   **Zero Build Dependencies**: Works on embedded systems, Alpine Linux, and environments without build tools
*   **Crash Detection**: Identifies and logs service crashes with exit codes and signals
*   **Flexible Configuration**: Supports configuration via JSON files and command-line arguments
*   **Configurable Service List**: Monitor any set of systemd services via config file or CLI
*   **Clean Architecture**: Separated configuration module (`config.py`) for better code organization
*   **Comprehensive Testing**: **133 unit tests** with **96% code coverage** - all tests run without dbus!
*   **Code Quality**: 100% pylint compliant with comprehensive pre-commit hooks
*   **CI/CD Pipeline**: Full GitHub Actions workflow with test result visualization
*   **Graceful Shutdown**: Handles signals (SIGINT, SIGTERM) to save state and exit cleanly

## How it Works

The monitor uses an **event-driven architecture** for efficient, real-time service monitoring:

### Architecture Overview

1.  **Initialization**:
    *   Loads configuration from JSON file (if specified) or command-line arguments
    *   Loads persistent state from JSON file (`/var/lib/service_monitor/service_states.json`)
    *   Connects to system D-Bus
    *   Subscribes to D-Bus signals from systemd manager
    *   For each monitored service, subscribes to `PropertiesChanged` signals
    *   Polls initial service states to establish baseline

2.  **Event-Driven Monitoring**:
    *   Listens for D-Bus `PropertiesChanged` callbacks from systemd
    *   When a service state changes, immediately processes the event
    *   Detects state transitions: inactive→active (start), active→inactive (stop), active→failed (crash)
    *   Tracks crash details including exit codes and termination signals
    *   Updates persistent counters (starts, stops, crashes)
    *   No continuous polling - callbacks provide instant notification

3.  **State Persistence**:
    *   Maintains JSON file with service state and counters
    *   Saves state after each significant event (counter changes)
    *   Preserves counters across script restarts
    *   Handles cleanup of unmonitored services
    *   Creates persistence directory if it doesn't exist

4.  **Logging**:
    *   Rotating log files (1MB max, 3 backups)
    *   Structured log entries with timestamps
    *   Different log levels for state changes, crashes, errors
    *   Formatted output for easy parsing
    *   Configurable debug logging

### Key Advantages Over Polling

- **Lower CPU Usage**: No continuous polling loop consuming resources
- **Instant Detection**: State changes detected immediately via callbacks (no delay)
- **More Reliable**: Direct notification from systemd, no missed states between polls
- **Cleaner Code**: Event-driven pattern is easier to understand and maintain
- **Scalable**: Can monitor many services without performance degradation

## Configuration

The systemd monitor supports flexible configuration through JSON files and command-line arguments.

### Configuration Module (`config.py`)

The integrated `config.py` module provides comprehensive configuration management:

**Configuration Options:**
- `monitored_services`: List of services to monitor (required)
- `log_file`: Path to log file (default: `/tmp/service_monitor.log`)
- `debug`: Enable debug logging (default: `false`)
- `max_retries`: Maximum retry attempts for failed operations (default: 3)
- `prometheus_enabled`: Enable Prometheus metrics exporter (default: `true`)
- `prometheus_port`: Port for Prometheus HTTP endpoint (default: `9100`)

**Reserved for Future Use:**
- `poll_interval`: Would set polling interval if we used polling (we don't)
- `stats_interval`: Interval for statistics generation (planned feature)

### Command-Line Options

Run with `-h` or `--help` to see all options:

```bash
python -m systemd_monitor.systemd_monitor --help
```

**Available Options:**
- `-h, --help`: Show help message and currently monitored services
- `-v, --version`: Show module version
- `-c, --clear`: Clear history log and persistence file
- `--config FILE`: Path to JSON configuration file
- `--services SERVICE [...]`: List of services to monitor (overrides config file)
- `-l FILE, --log-file FILE`: Path to log file (overrides config)
- `-p FILE, --persistence-file FILE`: Path to persistence file
- `--debug`: Enable debug logging

### Configuration Priority

Configuration is applied in this order (later overrides earlier):
1. Default values in code
2. JSON configuration file (if `--config` specified)
3. Command-line arguments

### Configuration File Example

Create a JSON config file (`/etc/systemd_monitor/config.json`):

```json
{
  "monitored_services": [
    "nginx.service",
    "postgresql.service",
    "redis.service"
  ],
  "log_file": "/var/log/systemd_monitor/services.log",
  "debug": false,
  "max_retries": 3
}
```

Use it:
```bash
python -m systemd_monitor.systemd_monitor --config /etc/systemd_monitor/config.json
```

### Default Monitored Services

If no configuration is provided, the script monitors these services by default:

```
wirepas-gateway.service
wirepas-sink-ttys1.service
wirepas-sink-ttys2.service
edger.connecteddev.service
edger.endries.service
devmgmt.service
hwcheck.service
provisioning.service
Node-Configuration.service
setup_cell_connect.service
mosquitto.service
wps_button_monitor.service
```

## Prometheus Metrics

The systemd monitor includes a built-in Prometheus metrics exporter for monitoring service health with Prometheus/Grafana.

### Available Metrics

**Gauges:**
- `systemd_service_state{service="<name>"}` - Current service state (1=active, 0=inactive, 2=activating, 3=deactivating, -1=failed, -2=unloaded)
- `systemd_service_last_change_timestamp{service="<name>"}` - Unix timestamp of last state change

**Counters (since monitor started):**
- `systemd_service_starts_total{service="<name>"}` - Total number of service starts
- `systemd_service_stops_total{service="<name>"}` - Total number of service stops
- `systemd_service_crashes_total{service="<name>"}` - Total number of service crashes (failed state)
- `systemd_service_restarts_total{service="<name>"}` - Total number of restart cycles

**Info:**
- `systemd_monitor_info{version="<ver>", monitored_services="<list>", service_count="<n>"}` - Monitor metadata

### Configuration

**Enable/Disable:**
```bash
# Enable (default)
systemd-monitor --services nginx.service

# Disable Prometheus
systemd-monitor --services nginx.service --no-prometheus

# Custom port (default: 9100)
systemd-monitor --services nginx.service --prometheus-port 8080
```

**Access Metrics:**
```bash
curl http://localhost:9100/metrics
```

### Example Prometheus Config

```yaml
scrape_configs:
  - job_name: 'systemd-monitor'
    static_configs:
      - targets: ['localhost:9100']
```

### Example Grafana Queries

**Service State Over Time:**
```promql
systemd_service_state{service="nginx.service"}
```

**Start Rate (per 5 minutes):**
```promql
rate(systemd_service_starts_total{service="nginx.service"}[5m])
```

**Crash Count:**
```promql
systemd_service_crashes_total{service="nginx.service"}
```

**All Services Up/Down:**
```promql
systemd_service_state == 1
```

### Notes

- Counters track deltas only (since monitor started), not historical persisted values
- State gauges are initialized from persisted state on startup
- If `prometheus-client` is not installed, metrics are automatically disabled
- Install with: `pip install prometheus-client>=0.14.0`

## Prerequisites

*   Python 3.8+ (tested on 3.8, 3.9, 3.10, 3.11)
*   **Pure Python dependencies only** - no C compiler required!
*   `jeepney>=0.8.0` - Pure Python D-Bus library (auto-installed)
*   `prometheus-client>=0.14.0` - Metrics export (optional)

### Why Pure Python?

This monitor uses **Jeepney**, a pure Python D-Bus library, making it perfect for:
- **Embedded systems** without build tools
- **Alpine Linux** and minimal container images
- **CI/CD environments** without system dependencies
- **Quick deployments** without compiling native extensions

### Performance Note

Jeepney is a pure Python implementation, which means it's slightly slower than C-based D-Bus libraries, but this is negligible for monitoring typical service counts (10-100 services). The event-driven architecture ensures efficient resource usage even with dozens of monitored services.

## Installation

### From Source

1. Clone the repository:
```bash
git clone https://github.com/istorrs/systemd_monitor.git
cd systemd_monitor
```

2. Install the package:
```bash
pip install -e .
```

This installs:
- `jeepney>=0.8.0` - Pure Python D-Bus library
- `prometheus-client>=0.14.0` - Metrics export

### Development Installation

For development, install with additional tools:
```bash
pip install -r requirements-dev.txt
```

This includes:
- Testing: `pytest`, `pytest-cov`, `pytest-mock`
- Code Quality: `black`, `flake8`, `pylint`, `mypy`
- Security: `bandit`, `safety`
- Pre-commit hooks: `pre-commit`

## Usage

### Basic Usage

Run the monitor with default services:
```bash
python -m systemd_monitor.systemd_monitor
```

### Configuration File Usage

Monitor specific services using a config file:
```bash
python -m systemd_monitor.systemd_monitor --config /etc/systemd_monitor/config.json
```

### Command-Line Configuration

Monitor specific services directly from CLI:
```bash
python -m systemd_monitor.systemd_monitor \
  --services nginx.service postgresql.service redis.service \
  --log-file /var/log/my-services.log \
  --debug
```

### Other Examples

1. **Clear history and restart fresh**:
   ```bash
   python -m systemd_monitor.systemd_monitor --clear
   ```

2. **Custom persistence location**:
   ```bash
   python -m systemd_monitor.systemd_monitor \
     --persistence-file ~/.config/systemd_monitor/state.json
   ```

3. **Debug mode** (verbose logging):
   ```bash
   python -m systemd_monitor.systemd_monitor --debug
   ```

## Output

### Log File Example

```
2025-10-23 10:15:23 - [INFO] wirepas-gateway.service:  inactive      -> active        (SubState: running)
2025-10-23 10:15:23 - [INFO] wirepas-gateway.service:  Incrementing start counter -> 1
2025-10-23 11:20:45 - [ERROR] mosquitto.service: **CRASH** (ExitCode: 1, Signal: 9 (SIGKILL))
2025-10-23 11:20:45 - [ERROR] mosquitto.service: Incrementing crash counter -> 1
```

### Persistent State File

Located at `/var/lib/service_monitor/service_states.json`:

```json
{
  "wirepas-gateway.service": {
    "last_state": "active",
    "last_change_time": "2025-10-23 10:15:23",
    "starts": 5,
    "stops": 4,
    "crashes": 0,
    "logged_unloaded": false
  },
  "mosquitto.service": {
    "last_state": "failed",
    "last_change_time": "2025-10-23 11:20:45",
    "starts": 3,
    "stops": 2,
    "crashes": 1,
    "logged_unloaded": false
  }
}
```

## Development

### Running Tests

All 51 tests run without requiring dbus installed (uses mocked dependencies):

```bash
# Full test suite
pytest

# With coverage report
pytest --cov=systemd_monitor --cov-report=term-missing

# Specific test file
pytest tests/test_systemd_monitor.py -v

# Fast mode (no coverage)
pytest --no-cov
```

**Test Coverage:**
- Total: **99% coverage**
- `config.py`: 100% coverage (28 tests)
- `systemd_monitor.py`: 99% coverage (47 tests)
- All tests use mocked dbus dependencies - no actual systemd required!

### Code Quality

The project enforces strict code quality standards:

```bash
# Run pylint (must score 10/10)
pylint systemd_monitor/ tests/

# Format code with Black
black systemd_monitor/ tests/

# Check formatting
black --check systemd_monitor/ tests/

# Type checking
mypy systemd_monitor/

# Flake8 linting
flake8 systemd_monitor/ tests/ --max-complexity=10 --max-line-length=100

# Security scans
bandit -r systemd_monitor/ -ll -i
safety check
```

### Pre-commit Hooks

The project includes comprehensive pre-commit hooks that run automatically:

```bash
# Install hooks
pre-commit install
```

**The hooks enforce 5 quality gates:**
1. **Pylint**: Code must score 10.00/10
2. **Black**: Code must be formatted correctly
3. **Flake8**: No syntax errors, complexity under 10, lines under 100 chars
4. **Bandit**: No security vulnerabilities
5. **Pytest**: All 77 unit tests must pass

See `PRE_COMMIT_HOOK.md` for details.

### CI/CD Pipeline

The project has a comprehensive GitHub Actions CI/CD pipeline:

**Workflow Jobs:**
1. **Lint**: Pylint checks (10/10 required)
2. **Test**: Full test suite on Python 3.8, 3.9, 3.10, 3.11
   - JUnit XML test results published to GitHub UI
   - Coverage reports uploaded to Codecov
3. **Code Quality**: Black, Flake8, MyPy checks
4. **Build**: Package build and validation
5. **Security**: Bandit and Safety vulnerability scans

**CI/CD Features:**
- ✅ Multi-version testing (Python 3.8-3.11)
- ✅ Test result visualization in GitHub Actions UI
- ✅ Coverage tracking with Codecov
- ✅ Security scanning
- ✅ Automated quality enforcement

The CI/CD workflow uses system-installed dbus packages (`python3-dbus`, `python3-gi`) with `PYTHONPATH` configuration to avoid build issues, but the tests themselves use mocked dependencies.

## Troubleshooting

### Test Results

You should see: **"77 passed in X.XX seconds"**

All tests now run successfully without dbus installed thanks to comprehensive mocking!

### Permission Errors

The default persistence path `/var/lib/service_monitor/` requires elevated permissions.

**Solutions:**
1. Run with sudo (not recommended for development)
2. Use custom persistence path in user directory:
   ```bash
   python -m systemd_monitor.systemd_monitor \
     -p ~/.config/systemd_monitor/state.json
   ```

### D-Bus Connection Errors

If you see D-Bus connection errors:
1. Ensure systemd is running: `systemctl status`
2. Check D-Bus is accessible: `busctl status`
3. Verify permissions to access system D-Bus

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes with tests
4. Ensure all quality checks pass (pre-commit hooks will help!)
5. Submit a pull request

**All contributions must:**
- Pass all 77 unit tests
- Achieve 10/10 pylint score
- Pass Black formatting
- Pass Flake8 checks
- Pass Bandit security scan
- Include documentation updates
- Maintain or improve code coverage (currently at 99%)

## Documentation

- **CHANGELOG.md**: Version history and migration guides
- **VERSIONING.md**: Versioning strategy and release process
- **PRE_COMMIT_HOOK.md**: Pre-commit hook documentation
- **PR2_ANALYSIS.md**: Development roadmap and architecture analysis
- **COMPLETION_SUMMARY.md**: Project completion status

## Architecture

### Modules

**`systemd_monitor.py`** - Main monitoring logic
- Event-driven D-Bus monitoring
- State change detection
- Crash tracking
- Logging and persistence

**`config.py`** - Configuration management
- JSON file parsing
- Command-line argument handling
- Configuration validation
- Default value management

### Testing Strategy

**Unit Tests** (`tests/test_*.py`):
- Mock all external dependencies (Jeepney D-Bus, systemd)
- Test business logic independently
- Fast execution (< 1 second)
- Run everywhere (no system dependencies)

**Integration Tests** (future):
- Would test actual systemd integration
- Require systemd and dbus
- Slower execution
- Environment-specific

## License

MIT License - see LICENSE file for details.

## Roadmap

**Completed:**
- ✅ Event-driven D-Bus architecture
- ✅ Config.py module integration
- ✅ GitHub Actions CI/CD pipeline
- ✅ Comprehensive type hints
- ✅ 133 unit tests with mocking (96% coverage!)
- ✅ Pre-commit hooks (5 quality gates)
- ✅ Test result visualization
- ✅ Security scanning
- ✅ Prometheus metrics export
- ✅ Pure Python Jeepney D-Bus implementation (no C compiler required!)

**In Progress:**
- 🔄 Integration test suite

**Planned:**
- 📋 Web dashboard for visualization
- 📋 Alerting capabilities
- 📋 Configuration hot-reload
- 📋 Systemd unit file for running as service

See [PR2_ANALYSIS.md](PR2_ANALYSIS.md) and [COMPLETION_SUMMARY.md](COMPLETION_SUMMARY.md) for detailed status.
